From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: violetc <58360096+s-yh-china@users.noreply.github.com>
Date: Thu, 3 Aug 2023 20:37:59 +0800
Subject: [PATCH] ReplayFile


diff --git a/src/main/java/top/leavesmc/leaves/replay/DigestOutputStream.java b/src/main/java/top/leavesmc/leaves/replay/DigestOutputStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..92a6478b337c4371e61b7e7878b242619398ecdd
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/replay/DigestOutputStream.java
@@ -0,0 +1,46 @@
+package top.leavesmc.leaves.replay;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.zip.Checksum;
+
+public class DigestOutputStream extends OutputStream {
+
+    private final Checksum sum;
+    private final OutputStream out;
+
+    public DigestOutputStream(OutputStream out, Checksum sum) {
+        this.out = out;
+        this.sum = sum;
+    }
+
+    @Override
+    public void close() throws IOException {
+        out.close();
+    }
+
+    @Override
+    public void flush() throws IOException {
+        out.flush();
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        sum.update(b);
+        out.write(b);
+    }
+
+    @Override
+    public void write(byte @NotNull [] b) throws IOException {
+        sum.update(b);
+        out.write(b);
+    }
+
+    @Override
+    public void write(byte @NotNull [] b, int off, int len) throws IOException {
+        sum.update(b, off, len);
+        out.write(b, off, len);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/replay/Photographer.java b/src/main/java/top/leavesmc/leaves/replay/Photographer.java
deleted file mode 100644
index 1cf7022d56626779bb9fe8174beeb1738499acfa..0000000000000000000000000000000000000000
--- a/src/main/java/top/leavesmc/leaves/replay/Photographer.java
+++ /dev/null
@@ -1,4 +0,0 @@
-package top.leavesmc.leaves.replay;
-
-public class Photographer {
-}
diff --git a/src/main/java/top/leavesmc/leaves/replay/RecordMetaData.java b/src/main/java/top/leavesmc/leaves/replay/RecordMetaData.java
new file mode 100644
index 0000000000000000000000000000000000000000..46a86cfce4aa859b8de7c126c22f64a999a4fe7a
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/replay/RecordMetaData.java
@@ -0,0 +1,23 @@
+package top.leavesmc.leaves.replay;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.UUID;
+
+public class RecordMetaData {
+
+    public static final int CURRENT_FILE_FORMAT_VERSION = 14;
+
+    public boolean singleplayer = false;
+    public String serverName = "Leaves";
+    public int duration = 0;
+    public long date;
+    public String mcversion;
+    public String fileFormat = "MCPR";
+    public int fileFormatVersion;
+    public int protocol;
+    public String generator;
+    public int selfId = -1;
+
+    public Set<UUID> players = new HashSet<>();
+}
diff --git a/src/main/java/top/leavesmc/leaves/replay/Recorder.java b/src/main/java/top/leavesmc/leaves/replay/Recorder.java
new file mode 100644
index 0000000000000000000000000000000000000000..2484e036aa87cb40e31b360988e26380a481726f
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/replay/Recorder.java
@@ -0,0 +1,224 @@
+package top.leavesmc.leaves.replay;
+
+import net.minecraft.SharedConstants;
+import net.minecraft.network.Connection;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.PacketSendListener;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
+import net.minecraft.network.protocol.game.ClientboundAddPlayerPacket;
+import net.minecraft.network.protocol.game.ClientboundBundlePacket;
+import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
+import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerChatPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
+import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
+import net.minecraft.network.protocol.login.ClientboundGameProfilePacket;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import top.leavesmc.leaves.LeavesLogger;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+public class Recorder extends Connection {
+
+    private static final LeavesLogger LOGGER = LeavesLogger.LOGGER;
+
+    private final ReplayFile replayFile;
+    private final ServerPhotographer photographer;
+    private final RecorderOption recorderOption;
+    private final RecordMetaData metaData;
+
+    private final ExecutorService saveService = Executors.newSingleThreadExecutor();
+
+    private boolean stopped = false;
+    private boolean paused = false;
+    private boolean resumeOnNextPacket = true;
+
+    private long startTime;
+    private long lastPacket;
+    private long timeShift = 0;
+
+    private boolean isSaved;
+    private boolean isSaving;
+
+    private ConnectionProtocol state = ConnectionProtocol.LOGIN;
+
+    public Recorder(ServerPhotographer photographer, RecorderOption recorderOption, File replayFile) throws IOException {
+        super(PacketFlow.CLIENTBOUND);
+
+        this.photographer = photographer;
+        this.recorderOption = recorderOption;
+        this.metaData = new RecordMetaData();
+        this.replayFile = new ReplayFile(replayFile);
+    }
+
+    public void start() {
+        startTime = System.currentTimeMillis();
+
+        metaData.singleplayer = false;
+        metaData.serverName = "Server Name"; // TODO custom name
+        metaData.generator = "leaves";
+        metaData.date = startTime;
+        metaData.mcversion = SharedConstants.getCurrentVersion().getName();
+
+        // TODO start event
+        savePacket(new ClientboundGameProfilePacket(photographer.getGameProfile()));
+        state = ConnectionProtocol.PLAY;
+
+        if (recorderOption.forceWeather != null) {
+            setWeather(recorderOption.forceWeather);
+        }
+    }
+
+    public void stop() {
+        stopped = true;
+    }
+
+    public void pauseRecording() {
+        resumeOnNextPacket = false;
+        paused = true;
+    }
+
+    public void resumeRecording() {
+        resumeOnNextPacket = true;
+    }
+
+    public void setWeather(RecorderOption.RecordWeather weather) {
+        weather.getPackets().forEach(this::savePacket);
+    }
+
+    public long getRecordedTime() {
+        final long base = System.currentTimeMillis() - startTime;
+        return base - timeShift;
+    }
+
+    private synchronized long getCurrentTimeAndUpdate() {
+        long now = getRecordedTime();
+        if (paused) {
+            if (resumeOnNextPacket) {
+                paused = false;
+            }
+            timeShift += now - lastPacket;
+            return lastPacket;
+        }
+        return lastPacket = now;
+    }
+
+    @Override
+    public boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public void send(@NotNull Packet<?> packet, @Nullable PacketSendListener callbacks) {
+        if (!stopped) {
+            if (packet instanceof ClientboundBundlePacket packet1) {
+                packet1.subPackets().forEach(subPacket -> {
+                    send(subPacket, null);
+                });
+            }
+
+            if (packet instanceof ClientboundAddPlayerPacket packet1) {
+                metaData.players.add(packet1.getPlayerId());
+                saveMetadata();
+            }
+
+            if (packet instanceof ClientboundDisconnectPacket) {
+                return;
+            }
+
+            if (recorderOption.forceDayTime != -1 && packet instanceof ClientboundSetTimePacket packet1) {
+                packet = new ClientboundSetTimePacket(packet1.getDayTime(), recorderOption.forceDayTime, false);
+            }
+
+            if (recorderOption.forceWeather != null && packet instanceof ClientboundGameEventPacket packet1) {
+                ClientboundGameEventPacket.Type type = packet1.getEvent();
+                if (type == ClientboundGameEventPacket.START_RAINING || type == ClientboundGameEventPacket.STOP_RAINING || type == ClientboundGameEventPacket.RAIN_LEVEL_CHANGE || type == ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE) {
+                    return;
+                }
+            }
+
+            if (recorderOption.ignoreChat && (packet instanceof ClientboundSystemChatPacket || packet instanceof ClientboundPlayerChatPacket)) {
+                return;
+            }
+
+            savePacket(packet);
+        }
+    }
+
+    private void saveMetadata() {
+        saveService.submit(() -> {
+            try {
+                replayFile.saveMetaData(metaData);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+    }
+
+    private void savePacket(Packet<?> packet) {
+        try {
+            final long timestamp = getCurrentTimeAndUpdate();
+            final boolean login = state == ConnectionProtocol.LOGIN;
+            saveService.submit(() -> {
+                try {
+                    replayFile.savePacket(timestamp, packet, login);
+                } catch (Exception e) {
+                    LOGGER.severe("Error saving packet");
+                    e.printStackTrace();
+                }
+            });
+        } catch (Exception e) {
+            LOGGER.severe("Error saving packet");
+            e.printStackTrace();
+        }
+    }
+
+    public boolean isSaved() {
+        return isSaved;
+    }
+
+    public CompletableFuture<Void> saveRecording(File dest) {
+        isSaved = true;
+        if (!isSaving) {
+            isSaving = true;
+            metaData.duration = (int) lastPacket;
+            return CompletableFuture.runAsync(() -> {
+                saveMetadata();
+                saveService.shutdown();
+                boolean interrupted = false;
+                try {
+                    saveService.awaitTermination(10, TimeUnit.SECONDS);
+                } catch (InterruptedException e) {
+                    interrupted = true;
+                }
+                try {
+                    replayFile.closeAndSave(dest);
+                } catch (IOException e) {
+                    e.printStackTrace();
+                    throw new CompletionException(e);
+                } finally {
+                    if (interrupted) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }, runnable -> {
+                final Thread thread = new Thread(runnable, "Recording file save thread");
+                thread.start();
+            });
+        } else {
+            LOGGER.warning("saveRecording() called twice");
+            return CompletableFuture.supplyAsync(() -> {
+                throw new IllegalStateException("saveRecording() called twice");
+            });
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/replay/RecorderOption.java b/src/main/java/top/leavesmc/leaves/replay/RecorderOption.java
new file mode 100644
index 0000000000000000000000000000000000000000..fdf46f1a7e3a1cf500ca5df0fd984205f52eae86
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/replay/RecorderOption.java
@@ -0,0 +1,39 @@
+package top.leavesmc.leaves.replay;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class RecorderOption {
+
+    public int recordDistance = -1;
+    public RecordWeather forceWeather = null;
+    public int forceDayTime = -1;
+    public boolean ignoreChat = false;
+    public boolean ignoreItem = false;
+
+    @NotNull
+    @Contract(" -> new")
+    public static RecorderOption createDefaultOption() {
+        return new RecorderOption();
+    }
+
+    public enum RecordWeather {
+        CLEAR(new ClientboundGameEventPacket(ClientboundGameEventPacket.STOP_RAINING, 0), new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, 0), new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, 0)),
+        RAIN(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0), new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, 1), new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, 0)),
+        THUNDER(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0), new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, 1), new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, 1));
+
+        private final List<Packet<?>> packets;
+
+        private RecordWeather(Packet<?>... packets) {
+            this.packets = List.of(packets);
+        }
+
+        public List<Packet<?>> getPackets() {
+            return packets;
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/replay/ReplayFile.java b/src/main/java/top/leavesmc/leaves/replay/ReplayFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c64052f0e4956de2ba3b3054900c2512ee74171
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/replay/ReplayFile.java
@@ -0,0 +1,139 @@
+package top.leavesmc.leaves.replay;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.SharedConstants;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.util.UUIDSerializer;
+
+import java.io.BufferedOutputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.List;
+import java.util.UUID;
+import java.util.zip.CRC32;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+public class ReplayFile {
+
+    private static final String RECORDING_FILE = "recording.tmcpr";
+    private static final String RECORDING_FILE_CRC32 = "recording.tmcpr.crc32";
+    private static final String MARKER_FILE = "markers.json";
+    private static final String META_FILE = "metaData.json";
+
+    private static final Gson MARKER_GSON = new GsonBuilder().registerTypeAdapter(ReplayMarker.class, new ReplayMarker.Serializer()).create();
+    private static final Gson META_GSON = new GsonBuilder().registerTypeAdapter(UUID.class, new UUIDSerializer()).create();
+
+    private final File tmpDir;
+    private final DataOutputStream packetStream;
+    private final CRC32 crc32 = new CRC32();
+
+    private final File markerFile;
+    private final File metaFile;
+
+    public ReplayFile(@NotNull File name) throws IOException {
+        this.tmpDir = new File(name.getParentFile(), name.getName() + ".tmp");
+        if (tmpDir.exists()) {
+            throw new IOException("recording file " + name + " already exists!");
+        } else if (!tmpDir.mkdirs()) {
+            throw new IOException("Failed to create temp directory for recording " + tmpDir);
+        }
+
+        File packetFile = new File(tmpDir, RECORDING_FILE);
+        metaFile = new File(tmpDir, META_FILE);
+        markerFile = new File(tmpDir, MARKER_FILE);
+
+        packetStream = new DataOutputStream(new DigestOutputStream(new BufferedOutputStream(new FileOutputStream(packetFile)), crc32));
+    }
+
+    private byte @NotNull [] getPacketBytes(Packet<?> packet, boolean isLogin) {
+        ConnectionProtocol state = isLogin ? ConnectionProtocol.LOGIN : ConnectionProtocol.PLAY;
+        int packetID = state.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf packetBuf = new FriendlyByteBuf(buf);
+        packetBuf.writeVarInt(packetID);
+        packet.write(packetBuf);
+
+        buf.readerIndex(0);
+        byte[] ret = new byte[buf.readableBytes()];
+        buf.readBytes(ret);
+        buf.release();
+        return ret;
+    }
+
+    public void saveMarkers(List<ReplayMarker> markers) throws IOException {
+        try (Writer writer = new OutputStreamWriter(new FileOutputStream(markerFile), StandardCharsets.UTF_8)){
+            writer.write(MARKER_GSON.toJson(markers));
+        }
+    }
+
+    public void saveMetaData(@NotNull RecordMetaData data) throws IOException {
+        data.fileFormat = "MCPR";
+        data.fileFormatVersion = RecordMetaData.CURRENT_FILE_FORMAT_VERSION;
+        data.protocol = SharedConstants.getCurrentVersion().getProtocolVersion();
+
+        try (Writer writer = new OutputStreamWriter(new FileOutputStream(metaFile), StandardCharsets.UTF_8)) {
+            writer.write(META_GSON.toJson(data));
+        }
+    }
+
+    public void savePacket(long timestamp, Packet<?> packet, boolean isLoginPhase) throws Exception {
+        byte[] data = getPacketBytes(packet, isLoginPhase);
+        packetStream.writeInt((int) timestamp);
+        packetStream.writeInt(data.length);
+        packetStream.write(data);
+    }
+
+    public synchronized void closeAndSave(File file) throws IOException {
+        packetStream.close();
+
+        String[] files = tmpDir.list();
+        if (files == null) {
+            return;
+        }
+
+        try (ZipOutputStream os = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(file)))) {
+            for (String fileName : files) {
+                os.putNextEntry(new ZipEntry(fileName));
+                File f = new File(tmpDir, fileName);
+                copy(new FileInputStream(f), os);
+            }
+
+            os.putNextEntry(new ZipEntry(RECORDING_FILE_CRC32));
+            Writer writer = new OutputStreamWriter(os);
+            writer.write(Long.toString(crc32.getValue()));
+            writer.flush();
+        }
+
+        for (String fileName : files) {
+            File f = new File(tmpDir, fileName);
+            Files.delete(f.toPath());
+        }
+        Files.delete(tmpDir.toPath());
+    }
+
+    private void copy(@NotNull InputStream in, OutputStream out) throws IOException {
+        byte[] buffer = new byte[8192];
+        int len;
+        while ((len = in.read(buffer)) > -1) {
+            out.write(buffer, 0, len);
+        }
+        in.close();
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/replay/ReplayMarker.java b/src/main/java/top/leavesmc/leaves/replay/ReplayMarker.java
new file mode 100644
index 0000000000000000000000000000000000000000..852f2098d93d4437fe79af06e454d8494b6decf1
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/replay/ReplayMarker.java
@@ -0,0 +1,43 @@
+package top.leavesmc.leaves.replay;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+
+import java.lang.reflect.Type;
+
+public class ReplayMarker {
+
+    public int time;
+    public String name;
+    public double x = 0;
+    public double y = 0;
+    public double z = 0;
+    public float phi = 0;
+    public float theta = 0;
+    public float varphi = 0;
+
+    public static class Serializer implements JsonSerializer<ReplayMarker> {
+        @Override
+        public JsonElement serialize(ReplayMarker src, Type typeOfSrc, JsonSerializationContext context) {
+            JsonObject ret = new JsonObject();
+            JsonObject value = new JsonObject();
+            JsonObject position = new JsonObject();
+            ret.add("realTimestamp", new JsonPrimitive(src.time));
+            ret.add("value", value);
+
+            value.add("name", new JsonPrimitive(src.name));
+            value.add("position", position);
+
+            position.add("x", new JsonPrimitive(src.x));
+            position.add("y", new JsonPrimitive(src.y));
+            position.add("z", new JsonPrimitive(src.z));
+            position.add("yaw", new JsonPrimitive(src.phi));
+            position.add("pitch", new JsonPrimitive(src.theta));
+            position.add("roll", new JsonPrimitive(src.varphi));
+            return ret;
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/UUIDSerializer.java b/src/main/java/top/leavesmc/leaves/util/UUIDSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..1329a725a2bd03d3ef6d7131d8bc77f20bf2e566
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/UUIDSerializer.java
@@ -0,0 +1,17 @@
+package top.leavesmc.leaves.util;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Type;
+import java.util.UUID;
+
+public class UUIDSerializer implements JsonSerializer<UUID> {
+    @Override
+    public JsonElement serialize(@NotNull UUID src, Type typeOfSrc, JsonSerializationContext context) {
+        return new JsonPrimitive(src.toString());
+    }
+}
