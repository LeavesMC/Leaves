From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7studio@foxmail.com>
Date: Sat, 5 Aug 2023 09:11:09 +0800
Subject: [PATCH] Add Photographer API


diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 16670088947fe126674fa9058f4fc8df01546a2c..752b3c7d974e3fd09ae5a270fe649976545b1f9e 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -194,7 +194,253 @@ public abstract class PlayerList {
         this.playerIo = saveHandler;
     }
     abstract public void loadAndSaveFiles(); // Paper - moved from DedicatedPlayerList constructor
+    // Leaves start - replay api
+    public void placeNewPhotographer(Connection connection, ServerPlayer player) {
+        player.isRealPlayer = true; // Paper
+        player.loginTime = System.currentTimeMillis(); // Paper
+        GameProfile gameprofile = player.getGameProfile();
+//        GameProfileCache usercache = this.server.getProfileCache();
+        String s;
+
+//        if (usercache != null) {
+//            Optional<GameProfile> optional = usercache.get(gameprofile.getId());
+//
+//            s = (String) optional.map(GameProfile::getName).orElse(gameprofile.getName());
+//            usercache.add(gameprofile);
+//        } else {
+            s = gameprofile.getName();
+//        }
+
+        CompoundTag nbttagcompound = this.load(player);
+        ResourceKey resourcekey;
+        // CraftBukkit start - Better rename detection
+        if (nbttagcompound != null && nbttagcompound.contains("bukkit")) {
+            CompoundTag bukkit = nbttagcompound.getCompound("bukkit");
+            s = bukkit.contains("lastKnownName", 8) ? bukkit.getString("lastKnownName") : s;
+        }
+        // CraftBukkit end
+
+        // Paper start - move logic in Entity to here, to use bukkit supplied world UUID.
+        if (nbttagcompound != null && nbttagcompound.contains("WorldUUIDMost") && nbttagcompound.contains("WorldUUIDLeast")) {
+            UUID uid = new UUID(nbttagcompound.getLong("WorldUUIDMost"), nbttagcompound.getLong("WorldUUIDLeast"));
+            org.bukkit.World bWorld = org.bukkit.Bukkit.getServer().getWorld(uid);
+            if (bWorld != null) {
+                resourcekey = ((CraftWorld) bWorld).getHandle().dimension();
+            } else {
+                resourcekey = Level.OVERWORLD;
+            }
+        } else if (nbttagcompound != null) {
+            // Vanilla migration support
+            // Paper end
+            DataResult<ResourceKey<Level>> dataresult = DimensionType.parseLegacy(new Dynamic(NbtOps.INSTANCE, nbttagcompound.get("Dimension"))); // CraftBukkit - decompile error
+            Logger logger = PlayerList.LOGGER;
+
+            Objects.requireNonNull(logger);
+            resourcekey = (ResourceKey) dataresult.resultOrPartial(logger::error).orElse(Level.OVERWORLD);
+        } else {
+            resourcekey = Level.OVERWORLD;
+        }
+
+        ResourceKey<Level> resourcekey1 = resourcekey;
+        ServerLevel worldserver = this.server.getLevel(resourcekey1);
+        ServerLevel worldserver1;
+
+        if (worldserver == null) {
+            PlayerList.LOGGER.warn("Unknown respawn dimension {}, defaulting to overworld", resourcekey1);
+            worldserver1 = this.server.overworld();
+        } else {
+            worldserver1 = worldserver;
+        }
+
+        // Paper start
+        if (nbttagcompound == null) {
+            player.spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT; // set Player SpawnReason to DEFAULT on first login
+            player.fudgeSpawnLocation(worldserver1); // only move to spawn on first login, otherwise, stay where you are....
+        }
+        // Paper end
+        player.setServerLevel(worldserver1);
+        String s1 = "local";
+
+        if (connection.getRemoteAddress() != null) {
+            s1 = io.papermc.paper.configuration.GlobalConfiguration.get().logging.logPlayerIpAddresses ? connection.getRemoteAddress().toString() : "<ip address withheld>"; // Paper
+        }
+
+        // Spigot start - spawn location event
+        Player spawnPlayer = player.getBukkitEntity();
+        org.spigotmc.event.player.PlayerSpawnLocationEvent ev = new com.destroystokyo.paper.event.player.PlayerInitialSpawnEvent(spawnPlayer, spawnPlayer.getLocation()); // Paper use our duplicate event
+        this.cserver.getPluginManager().callEvent(ev);
+
+        Location loc = ev.getSpawnLocation();
+        worldserver1 = ((CraftWorld) loc.getWorld()).getHandle();
+
+        player.spawnIn(worldserver1);
+        player.gameMode.setLevel((ServerLevel) player.level());
+        // Paper start - set raw so we aren't fully joined to the world (not added to chunk or world)
+        player.setPosRaw(loc.getX(), loc.getY(), loc.getZ());
+        player.setRot(loc.getYaw(), loc.getPitch());
+        // Paper end
+        // Spigot end
+
+        // CraftBukkit - Moved message to after join
+        // PlayerList.LOGGER.info("{}[{}] logged in with entity id {} at ({}, {}, {})", new Object[]{entityplayer.getName().getString(), s1, entityplayer.getId(), entityplayer.getX(), entityplayer.getY(), entityplayer.getZ()});
+        LevelData worlddata = worldserver1.getLevelData();
 
+        player.loadGameTypes(nbttagcompound);
+        ServerGamePacketListenerImpl playerconnection = new ServerGamePacketListenerImpl(this.server, connection, player);
+        GameRules gamerules = worldserver1.getGameRules();
+        boolean flag = gamerules.getBoolean(GameRules.RULE_DO_IMMEDIATE_RESPAWN);
+        boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
+
+        // Spigot - view distance
+        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.synchronizedRegistries, worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), worldserver1.getWorld().getSendViewDistance(), worldserver1.getWorld().getSimulationDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat(), player.getLastDeathLocation(), player.getPortalCooldown())); // Paper - replace old player chunk management
+        player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
+        playerconnection.send(new ClientboundUpdateEnabledFeaturesPacket(FeatureFlags.REGISTRY.toNames(worldserver1.enabledFeatures())));
+        playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
+        playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
+        playerconnection.send(new ClientboundPlayerAbilitiesPacket(player.getAbilities()));
+        playerconnection.send(new ClientboundSetCarriedItemPacket(player.getInventory().selected));
+        playerconnection.send(new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getRecipes()));
+        playerconnection.send(new ClientboundUpdateTagsPacket(TagNetworkSerialization.serializeTagsToNetwork(this.registries)));
+        this.sendPlayerPermissionLevel(player);
+        player.getStats().markAllDirty();
+        player.getRecipeBook().sendInitialRecipeBook(player);
+        this.updateEntireScoreboard(worldserver1.getScoreboard(), player);
+        this.server.invalidateStatus();
+        MutableComponent ichatmutablecomponent;
+
+        if (player.getGameProfile().getName().equalsIgnoreCase(s)) {
+            ichatmutablecomponent = Component.translatable("multiplayer.player.joined", player.getDisplayName());
+        } else {
+            ichatmutablecomponent = Component.translatable("multiplayer.player.joined.renamed", player.getDisplayName(), s);
+        }
+        // CraftBukkit start
+        ichatmutablecomponent.withStyle(ChatFormatting.YELLOW);
+        Component joinMessage = ichatmutablecomponent; // Paper - Adventure
+
+        playerconnection.teleport(player.getX(), player.getY(), player.getZ(), player.getYRot(), player.getXRot());
+        ServerStatus serverping = this.server.getStatus();
+
+        if (serverping != null) {
+            player.sendServerStatus(serverping);
+        }
+
+        // entityplayer.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(this.players)); // CraftBukkit - replaced with loop below
+        this.players.add(player);
+        this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player); // Spigot
+        this.playersByUUID.put(player.getUUID(), player);
+        // this.broadcastAll(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(entityplayer))); // CraftBukkit - replaced with loop below
+
+        // Paper start - correctly register player BEFORE PlayerJoinEvent, so the entity is valid and doesn't require tick delay hacks
+        player.supressTrackerForLogin = true;
+        worldserver1.addNewPlayer(player);
+        this.server.getCustomBossEvents().onPlayerConnect(player); // see commented out section below worldserver.addPlayerJoin(entityplayer);
+        mountSavedVehicle(player, worldserver1, nbttagcompound);
+        // Paper end
+        // CraftBukkit start
+        CraftPlayer bukkitPlayer = player.getBukkitEntity();
+
+        // Ensure that player inventory is populated with its viewer
+        player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
+
+        PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
+        this.cserver.getPluginManager().callEvent(playerJoinEvent);
+
+        if (!player.connection.isAcceptingMessages()) {
+            return;
+        }
+
+        // Leaves start - bot support
+        if (top.leavesmc.leaves.LeavesConfig.fakeplayerSupport) {
+            ServerBot bot = ServerBot.getBot(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT));
+            if (bot != null) {
+                bot.die(bot.damageSources().fellOutOfWorld()); // Leaves - remove bot with the same name
+                this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player);
+                this.playersByUUID.put(player.getUUID(), player);
+            }
+            ServerBot.getBots().forEach(bot1 ->
+                bot1.render(playerconnection, true,player.getBukkitEntity().getWorld() == bot1.getBukkitEntity().getWorld())); // Leaves - render bot
+        }
+        // Leaves end - bot support
+        top.leavesmc.leaves.protocol.PcaSyncProtocol.onJoin(player); // Leaves - pca
+        top.leavesmc.leaves.protocol.BBORProtocol.onPlayerLoggedIn(player); // Leaves - bbor
+        top.leavesmc.leaves.protocol.JadeProtocol.onPlayerJoin(player); // Leaves - Jade
+        top.leavesmc.leaves.protocol.AppleSkinProtocol.onPlayerLoggedIn(player); // Leaves - appleskin
+        top.leavesmc.leaves.protocol.CarpetServerProtocol.onPlayerJoin(player); // Leaves - carpet
+        top.leavesmc.leaves.protocol.bladeren.MsptSyncProtocol.onPlayerJoin(player); // Leaves - mspt sync
+        top.leavesmc.leaves.protocol.bladeren.LeavesProtocol.onPlayerJoin(player); // Leaves - leaves protocol
+
+        final net.kyori.adventure.text.Component jm = playerJoinEvent.joinMessage();
+
+        if (jm != null && !jm.equals(net.kyori.adventure.text.Component.empty())) { // Paper - Adventure
+            joinMessage = PaperAdventure.asVanilla(jm); // Paper - Adventure
+            this.server.getPlayerList().broadcastSystemMessage(joinMessage, false); // Paper - Adventure
+        }
+        // CraftBukkit end
+
+        // CraftBukkit start - sendAll above replaced with this loop
+        ClientboundPlayerInfoUpdatePacket packet = ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(player));
+
+        final List<ServerPlayer> onlinePlayers = Lists.newArrayListWithExpectedSize(this.players.size() - 1); // Paper - use single player info update packet
+        for (int i = 0; i < this.players.size(); ++i) {
+            ServerPlayer entityplayer1 = (ServerPlayer) this.players.get(i);
+
+            if (entityplayer1.getBukkitEntity().canSee(bukkitPlayer)) {
+                entityplayer1.connection.send(packet);
+            }
+
+            if (entityplayer1 == player || !bukkitPlayer.canSee(entityplayer1.getBukkitEntity())) { // Paper - don't include joining player
+                continue;
+            }
+
+            onlinePlayers.add(entityplayer1); // Paper - use single player info update packet
+        }
+        // Paper start - use single player info update packet
+        if (!onlinePlayers.isEmpty()) {
+            player.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(onlinePlayers));
+        }
+        // Paper end
+        player.sentListPacket = true;
+        player.supressTrackerForLogin = false; // Paper
+        ((ServerLevel)player.level()).getChunkSource().chunkMap.addEntity(player); // Paper - track entity now
+        // CraftBukkit end
+
+        //player.getEntityData().refresh(player); // CraftBukkit - BungeeCord#2321, send complete data to self on spawn Paper - THIS IS NOT NEEDED ANYMORE
+
+        this.sendLevelInfo(player, worldserver1);
+
+        // CraftBukkit start - Only add if the player wasn't moved in the event
+        if (player.level() == worldserver1 && !worldserver1.players().contains(player)) {
+            worldserver1.addNewPlayer(player);
+            this.server.getCustomBossEvents().onPlayerConnect(player);
+        }
+
+        worldserver1 = player.serverLevel(); // CraftBukkit - Update in case join event changed it
+        // CraftBukkit end
+        this.server.getServerResourcePack().ifPresent((minecraftserver_serverresourcepackinfo) -> {
+            player.sendTexturePack(minecraftserver_serverresourcepackinfo.url(), minecraftserver_serverresourcepackinfo.hash(), minecraftserver_serverresourcepackinfo.isRequired(), minecraftserver_serverresourcepackinfo.prompt());
+        });
+        Iterator iterator = player.getActiveEffects().iterator();
+
+        while (iterator.hasNext()) {
+            MobEffectInstance mobeffect = (MobEffectInstance) iterator.next();
+
+            playerconnection.send(new ClientboundUpdateMobEffectPacket(player.getId(), mobeffect));
+        }
+
+        // Paper start - move vehicle into method so it can be called above - short circuit around that code
+        onPlayerJoinFinish(player, worldserver1, s1);
+        // Paper start - Send empty chunk, so players aren't stuck in the world loading screen with our chunk system not sending chunks when dead
+        if (player.isDeadOrDying()) {
+            net.minecraft.core.Holder<net.minecraft.world.level.biome.Biome> plains = worldserver1.registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.BIOME)
+                .getHolderOrThrow(net.minecraft.world.level.biome.Biomes.PLAINS);
+            player.connection.send(new net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket(
+                new net.minecraft.world.level.chunk.EmptyLevelChunk(worldserver1, player.chunkPosition(), plains),
+                worldserver1.getLightEngine(), null, null, false)
+            );
+        }
+        // Paper end
+    }
+    // Leaves end - replay api
     public void placeNewPlayer(Connection connection, ServerPlayer player) {
         player.isRealPlayer = true; // Paper
         player.loginTime = System.currentTimeMillis(); // Paper
diff --git a/src/main/java/top/leavesmc/leaves/entity/CraftPhotographer.java b/src/main/java/top/leavesmc/leaves/entity/CraftPhotographer.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b5da8db2a12156cf04d1f4008a204436441d295
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/entity/CraftPhotographer.java
@@ -0,0 +1,28 @@
+package top.leavesmc.leaves.entity;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.replay.ServerPhotographer;
+
+public class CraftPhotographer extends CraftPlayer implements Photographer {
+    public CraftPhotographer(CraftServer server, ServerPlayer entity) {super(server, entity);}
+    @Override
+    public @NotNull String getId() {
+        return getHandle().createState.id;
+    }
+    @Override
+    public ServerPhotographer getHandle() {
+        return (ServerPhotographer) entity;
+    }
+
+    public void setHandle(final ServerPhotographer entity) {
+        super.setHandle(entity);
+    }
+
+    @Override
+    public String toString() {
+        return "CraftPhotographer{" + "name=" + getName() + '}';
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/entity/CraftPhotographerManager.java b/src/main/java/top/leavesmc/leaves/entity/CraftPhotographerManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..edb75a5d422dbb890dc5c68dea1475019946456b
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/entity/CraftPhotographerManager.java
@@ -0,0 +1,70 @@
+package top.leavesmc.leaves.entity;
+
+import com.google.common.collect.Lists;
+import org.bukkit.Location;
+import org.bukkit.util.Consumer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.replay.ServerPhotographer;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.UUID;
+
+public class CraftPhotographerManager implements PhotographerManager{
+    private final Collection<Photographer> photographerViews = Collections.unmodifiableList(Lists.transform(ServerPhotographer.getPhotographers(),ServerPhotographer::getBukkitPlayer));
+
+    @Override
+    public @Nullable Photographer getPhotographer(@NotNull UUID uuid) {
+        return ServerPhotographer.getPhotographer(uuid).getBukkitPlayer();
+    }
+
+    @Override
+    public @Nullable Photographer getPhotographer(@NotNull String id) {
+        return ServerPhotographer.getPhotographer(id).getBukkitPlayer();
+    }
+
+    @Override
+    public @Nullable Photographer createPhotographer(@NotNull String id, @NotNull Location location) {
+        ServerPhotographer photographer = new ServerPhotographer.PhotographerCreateState(location, id).createSync();
+        if (photographer != null) {
+            return photographer.getBukkitPlayer();
+        }
+        return null;
+    }
+
+    @Override
+    public void createPhotographer(@NotNull String id, @NotNull Location location, Consumer<Photographer> consumer) {
+        new ServerPhotographer.PhotographerCreateState(location, id).createAsync((serverPhotographer -> {
+            consumer.accept(serverPhotographer.getBukkitPlayer());
+        }));
+    }
+
+    @Override
+    public void removePhotographer(@NotNull String id) {
+        ServerPhotographer photographer = ServerPhotographer.getPhotographer(id);
+        if (photographer != null) {
+            photographer.remove(true);
+        }
+    }
+
+    @Override
+    public void removePhotographer(@NotNull UUID uuid) {
+        ServerPhotographer photographer = ServerPhotographer.getPhotographer(uuid);
+        if (photographer != null) {
+            photographer.remove(true);
+        }
+    }
+
+    @Override
+    public void removeAllPhotographers() {
+        for(ServerPhotographer photographer:ServerPhotographer.getPhotographers()){
+            photographer.remove(true);
+        }
+    }
+    @Override
+    public Collection<Photographer> getPhotographers() {
+        return photographerViews;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/replay/PhotographerCommand.java b/src/main/java/top/leavesmc/leaves/replay/PhotographerCommand.java
index 1d5a115658bbb8e01f1830c2fad2fdb69dacc01b..10432a54725a977ae5c8fa834018b03534440221 100644
--- a/src/main/java/top/leavesmc/leaves/replay/PhotographerCommand.java
+++ b/src/main/java/top/leavesmc/leaves/replay/PhotographerCommand.java
@@ -9,6 +9,7 @@ import org.bukkit.command.CommandSender;
 import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.entity.Player;
 import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -18,7 +19,7 @@ public class PhotographerCommand extends Command {
     public PhotographerCommand(String name) {
         super(name);
         this.description = "Photographer Command";
-        this.usageMessage = "/photographer [create]";
+        this.usageMessage = "/photographer [create | remove]";
         this.setPermission("bukkit.command.photographer");
     }
 
@@ -28,11 +29,12 @@ public class PhotographerCommand extends Command {
 
         if (args.length <= 1) {
             list.add("create");
+            list.add("remove");
         }
 
         if (args.length == 2) {
             switch (args[0]) {
-                case "create" -> list.add("<PhotographerName>");
+                case "create", "remove" -> list.add("<PhotographerName>");
             }
         }
 
@@ -50,6 +52,7 @@ public class PhotographerCommand extends Command {
 
         switch (args[0]) {
             case "create" -> this.onCreate(sender, args);
+            case "remove" -> this.onRemove(sender, args);
 
             default -> {
                 sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
@@ -91,36 +94,32 @@ public class PhotographerCommand extends Command {
         }
     }
 
-    private boolean canCreate(CommandSender sender, @NotNull String name) {
-        if (!name.matches("^[a-zA-Z0-9_]{4,16}$")) {
-            sender.sendMessage(ChatColor.RED + "This name is illegal");
+    private boolean canCreate(CommandSender sender, @NotNull String id) {
+        if (!id.matches("^[a-zA-Z0-9_]{4,16}$")) {
+            sender.sendMessage(ChatColor.RED + "This id is illegal");
+            return false;
+        }
+
+        if (Bukkit.getPlayer(id) != null || ServerPhotographer.getPhotographer(id) != null) {
+            sender.sendMessage(ChatColor.RED + "This photographer is in server");
             return false;
         }
-//
-//        if (Bukkit.getPlayer(name) != null || ServerBot.getBot(name) != null) {
-//            sender.sendMessage(ChatColor.RED + "This player is in server");
-//            return false;
-//        }
-//
-//        if (top.leavesmc.leaves.LeavesConfig.unableFakeplayerNames.contains(name)) {
-//            sender.sendMessage(ChatColor.RED + "This name is not allowed");
-//            return false;
-//        }
-//
-//        if (ServerBot.getBots().size() >= top.leavesmc.leaves.LeavesConfig.fakeplayerLimit) {
-//            sender.sendMessage(ChatColor.RED + "Photographer limit is full");
-//            return false;
-//        }
 
         return true;
     }
+    private void onRemove(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            sender.sendMessage(ChatColor.RED + "Use /photographer remove <name> to remove a photographer");
+            return;
+        }
+
+        ServerPhotographer photographer = ServerPhotographer.getPhotographer(args[1]);
 
-    @NotNull
-    private static String formatPlayerNameList(@NotNull List<String> list) {
-        if (list.isEmpty()) {
-            return "";
+        if (photographer  == null) {
+            sender.sendMessage(ChatColor.RED + "This photographer is not in server");
+            return;
         }
-        String string = list.toString();
-        return string.substring(1, string.length() - 1);
+
+        photographer.remove(true);
     }
 }
diff --git a/src/main/java/top/leavesmc/leaves/replay/ServerPhotographer.java b/src/main/java/top/leavesmc/leaves/replay/ServerPhotographer.java
index 4c7f9c9efe2a18216878f5449913d785c841713c..d57aee19507e088e0ef6092ab89d854bc7c7bf41 100644
--- a/src/main/java/top/leavesmc/leaves/replay/ServerPhotographer.java
+++ b/src/main/java/top/leavesmc/leaves/replay/ServerPhotographer.java
@@ -11,6 +11,11 @@ import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
 import org.bukkit.plugin.Plugin;
 import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.entity.Bot;
+import top.leavesmc.leaves.entity.CraftBot;
+import top.leavesmc.leaves.entity.CraftPhotographer;
+import top.leavesmc.leaves.entity.Photographer;
 
 import java.io.File;
 import java.io.IOException;
@@ -35,6 +40,9 @@ public class ServerPhotographer extends ServerPlayer {
         super(server, world, profile);
     }
 
+    public static List<ServerPhotographer> getPhotographers(){
+        return photographers;
+    }
     public static ServerPhotographer createPhotographer(@NotNull PhotographerCreateState state) throws IOException {
         if (!isCreateLegal(state.id)) {
             return null;
@@ -50,7 +58,7 @@ public class ServerPhotographer extends ServerPlayer {
         photographer.createState = state;
 
         photographer.recorder.start();
-        MinecraftServer.getServer().getPlayerList().placeNewPlayer(photographer.recorder, photographer);
+        MinecraftServer.getServer().getPlayerList().placeNewPhotographer(photographer.recorder, photographer);
         photographer.setGameMode(GameType.SPECTATOR);
         photographer.setInvisible(true);
         photographer.serverLevel().chunkSource.move(photographer);
@@ -89,6 +97,36 @@ public class ServerPhotographer extends ServerPlayer {
             }
         }
     }
+    public static ServerPhotographer getPhotographer(String id) {
+        ServerPhotographer photographer = null;
+        for (ServerPhotographer p : photographers) {
+            if (p.createState.id.equals(id)) {
+                photographer = p;
+                break;
+            }
+        }
+        return photographer;
+    }
+
+    public static ServerPhotographer getPhotographer(UUID uuid) {
+        ServerPhotographer photographer = null;
+        for (ServerPhotographer p : photographers) {
+            if (p.uuid == uuid) {
+                photographer = p;
+                break;
+            }
+        }
+        return photographer;
+    }
+    public Photographer getBukkitPlayer() {
+        return getBukkitEntity();
+    }
+
+    @Override
+    @NotNull
+    public CraftPhotographer getBukkitEntity() {
+        return (CraftPhotographer) super.getBukkitEntity();
+    }
 
     public static class PhotographerCreateState {
 
@@ -100,12 +138,13 @@ public class ServerPhotographer extends ServerPlayer {
             this.id = id;
         }
 
-        public void createSync() {
+        public ServerPhotographer createSync() {
             try {
-                ServerPhotographer serverPhotographer = createPhotographer(this);
+                return createPhotographer(this);
             } catch (IOException e) {
                 e.printStackTrace();
             }
+            return null;
         }
 
         public void createAsync(Consumer<ServerPhotographer> consumer) {
