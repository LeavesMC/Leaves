From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Lumine1909 <133463833+Lumine1909@users.noreply.github.com>
Date: Wed, 22 May 2024 10:12:22 +0800
Subject: [PATCH] Bytebuf API


diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 975062e67278614220eab0c301019a235c7953b7..c7623096107a2fd7efd54146b952669fc627a149 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -469,7 +469,7 @@ public abstract class PlayerList {
         if (!player.connection.isAcceptingMessages()) {
             return;
         }
-
+        getServer().server.getBytebufHandler().injectPlayer(player);
         org.leavesmc.leaves.protocol.core.LeavesProtocolManager.handlePlayerJoin(player); // Leaves - protocol
 
         // Leaves start - bot support
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 405a04f2711e26e22d7dd091745b5b5a01d724d9..dea7f028f0bd81e0811f37ce226da50dd4ed158b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -307,6 +307,7 @@ public final class CraftServer implements Server {
     private final io.papermc.paper.potion.PaperPotionBrewer potionBrewer; // Paper - Custom Potion Mixes
     private final org.leavesmc.leaves.entity.CraftBotManager botManager = new org.leavesmc.leaves.entity.CraftBotManager(); // Leaves
     private final org.leavesmc.leaves.entity.CraftPhotographerManager photographerManager = new org.leavesmc.leaves.entity.CraftPhotographerManager(); // Leaves
+    private final org.leavesmc.leaves.bytebuf.internal.InternalBytebufHandler internalBytebufHandler = new org.leavesmc.leaves.bytebuf.internal.InternalBytebufHandler(); // Leaves
 
     // Paper start - Folia region threading API
     private final io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler regionizedScheduler = new io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler();
@@ -3291,4 +3292,13 @@ public final class CraftServer implements Server {
         return photographerManager;
     }
     // Leaves end - replay mod api
+    // Leaves start - Bytebuf API
+    @Override
+    public org.leavesmc.leaves.bytebuf.BytebufManager getBytebufManager() {
+        return internalBytebufHandler.getManager();
+    }
+    public org.leavesmc.leaves.bytebuf.internal.InternalBytebufHandler getBytebufHandler() {
+        return internalBytebufHandler;
+    }
+    // Leaves end - Bytebuf API
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 25a5ce110c0515f5a0ee5f287a7f3dd029a8f29f..1eb60f1d9bec4b11bb1d0242266d6e084e53b372 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -3519,4 +3519,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setSendViewDistance(final int viewDistance) {
         this.getHandle().setSendViewDistance(viewDistance);
     }
+    // Leaves start - Bytebuf API
+    @Override
+    public void sendPacket(org.leavesmc.leaves.bytebuf.packet.Packet packet) {
+        ((CraftServer) getServer()).getBytebufHandler().applyPacketToPlayer(this, packet);
+    }
+    @Override
+    public void sendPacket(org.leavesmc.leaves.bytebuf.Bytebuf bytebuf, org.leavesmc.leaves.bytebuf.packet.PacketType type) {
+        ((CraftServer) getServer()).getBytebufHandler().applyPacketToPlayer(this, new org.leavesmc.leaves.bytebuf.packet.Packet(type, bytebuf));
+    }
+    // Leaves end - Bytebuf API
 }
diff --git a/src/main/java/org/leavesmc/leaves/bytebuf/SimpleBytebufManager.java b/src/main/java/org/leavesmc/leaves/bytebuf/SimpleBytebufManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..443f7f6e0b8d40eaafb8009b3b7e405c6ec78d02
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/bytebuf/SimpleBytebufManager.java
@@ -0,0 +1,35 @@
+package org.leavesmc.leaves.bytebuf;
+
+import io.netty.buffer.Unpooled;
+import org.bukkit.plugin.Plugin;
+import org.leavesmc.leaves.bytebuf.internal.InternalBytebufHandler;
+import org.leavesmc.leaves.bytebuf.packet.PacketListener;
+
+public class SimpleBytebufManager implements BytebufManager {
+
+    private final InternalBytebufHandler internal;
+
+    public SimpleBytebufManager(InternalBytebufHandler internal) {
+        this.internal = internal;
+    }
+
+    @Override
+    public void registerListener(Plugin plugin, PacketListener listener) {
+        internal.listenerMap.put(listener, plugin);
+    }
+
+    @Override
+    public void unregisterListener(Plugin plugin, PacketListener listener) {
+        internal.listenerMap.remove(listener);
+    }
+
+    @Override
+    public Bytebuf newBytebuf(int size) {
+        return new WrappedBytebuf(Unpooled.buffer(size));
+    }
+
+    @Override
+    public Bytebuf toBytebuf(byte[] bytes) {
+        return new WrappedBytebuf(Unpooled.wrappedBuffer(bytes));
+    }
+}
diff --git a/src/main/java/org/leavesmc/leaves/bytebuf/WrappedBytebuf.java b/src/main/java/org/leavesmc/leaves/bytebuf/WrappedBytebuf.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f4aca3138487ef69e674d27a6bbba033e56c4f1
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/bytebuf/WrappedBytebuf.java
@@ -0,0 +1,163 @@
+package org.leavesmc.leaves.bytebuf;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.RegistryFriendlyByteBuf;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.ComponentSerialization;
+
+public class WrappedBytebuf implements Bytebuf {
+
+    private final FriendlyByteBuf buf;
+
+    public WrappedBytebuf(ByteBuf buf) {
+        this.buf = new FriendlyByteBuf(buf);
+    }
+
+    public FriendlyByteBuf getFriendlyBytebuf() {
+        return buf;
+    }
+
+    @Override
+    public byte[] toArray() {
+        return buf.array();
+    }
+
+    @Override
+    public Bytebuf skipBytes(int i) {
+        buf.skipBytes(i);
+        return this;
+    }
+
+    @Override
+    public int readerIndex() {
+        return buf.readerIndex();
+    }
+
+    @Override
+    public Bytebuf readerIndex(int i) {
+        buf.readerIndex(i);
+        return this;
+    }
+
+    @Override
+    public int writerIndex() {
+        return buf.writerIndex();
+    }
+
+    @Override
+    public Bytebuf writerIndex(int i) {
+        buf.writerIndex(i);
+        return this;
+    }
+
+    @Override
+    public Bytebuf resetReaderIndex() {
+        buf.resetReaderIndex();
+        return this;
+    }
+
+    @Override
+    public Bytebuf resetWriterIndex() {
+        buf.resetWriterIndex();
+        return this;
+    }
+
+    @Override
+    public Bytebuf writeByte(int i) {
+        buf.writeByte(i);
+        return this;
+    }
+
+    @Override
+    public byte readByte() {
+        return buf.readByte();
+    }
+
+    @Override
+    public Bytebuf writeBoolean(boolean b) {
+        buf.writeBoolean(b);
+        return this;
+    }
+
+    @Override
+    public boolean readBoolean() {
+        return buf.readBoolean();
+    }
+
+    @Override
+    public Bytebuf writeShort(int i) {
+        buf.writeShort(i);
+        return this;
+    }
+
+    @Override
+    public short readShort() {
+        return buf.readShort();
+    }
+
+    @Override
+    public Bytebuf writeInt(int i) {
+        buf.writeShort(i);
+        return this;
+    }
+
+    @Override
+    public int readInt() {
+        return buf.readInt();
+    }
+
+    @Override
+    public Bytebuf writeLong(long i) {
+        buf.writeLong(i);
+        return this;
+    }
+
+    @Override
+    public long readLong() {
+        return buf.readLong();
+    }
+
+    @Override
+    public Bytebuf writeUTFString(String utf) {
+        buf.writeUtf(utf);
+        return this;
+    }
+
+    @Override
+    public String readUTFString() {
+        return buf.readUtf();
+    }
+
+    @Override
+    public Bytebuf writeComponentPlain(String str) {
+        RegistryFriendlyByteBuf regBuf = new RegistryFriendlyByteBuf(Unpooled.buffer(), RegistryAccess.EMPTY);
+        ComponentSerialization.STREAM_CODEC.encode(regBuf, Component.literal(str));
+        buf.writeBytes(regBuf.array());
+        return this;
+    }
+
+    @Override
+    public String readComponentPlain() {
+        return ComponentSerialization.STREAM_CODEC.decode(new RegistryFriendlyByteBuf(buf, RegistryAccess.EMPTY)).getString();
+    }
+
+    @Override
+    public Bytebuf writeComponentJson(String json) {
+        Component component = Component.Serializer.fromJson(json, RegistryAccess.EMPTY);
+        if (component == null) {
+            throw new IllegalArgumentException("The String " + json + " can not be serialize to Minecraft chat component");
+        }
+        RegistryFriendlyByteBuf regBuf = new RegistryFriendlyByteBuf(Unpooled.buffer(), RegistryAccess.EMPTY);
+        ComponentSerialization.STREAM_CODEC.encode(regBuf, component);
+        buf.writeBytes(regBuf.array());
+        return this;
+    }
+
+    @Override
+    public String readComponentJson() {
+        return Component.Serializer.toJson(ComponentSerialization.STREAM_CODEC.decode(new RegistryFriendlyByteBuf(buf, RegistryAccess.EMPTY)), RegistryAccess.EMPTY);
+    }
+}
diff --git a/src/main/java/org/leavesmc/leaves/bytebuf/internal/InternalBytebufHandler.java b/src/main/java/org/leavesmc/leaves/bytebuf/internal/InternalBytebufHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..35d66678dfe391dcde4061775f5735d68a6b8e0f
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/bytebuf/internal/InternalBytebufHandler.java
@@ -0,0 +1,193 @@
+package org.leavesmc.leaves.bytebuf.internal;
+
+import com.google.common.collect.ImmutableMap;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import net.minecraft.network.Connection;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.RegistryFriendlyByteBuf;
+import net.minecraft.network.codec.StreamCodec;
+import net.minecraft.network.protocol.BundleDelimiterPacket;
+import net.minecraft.network.protocol.BundlePacket;
+import net.minecraft.network.protocol.game.*;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.Plugin;
+import org.leavesmc.leaves.bytebuf.Bytebuf;
+import org.leavesmc.leaves.bytebuf.BytebufManager;
+import org.leavesmc.leaves.bytebuf.SimpleBytebufManager;
+import org.leavesmc.leaves.bytebuf.WrappedBytebuf;
+import org.leavesmc.leaves.bytebuf.packet.Packet;
+import org.leavesmc.leaves.bytebuf.packet.PacketListener;
+import org.leavesmc.leaves.bytebuf.packet.PacketType;
+
+import java.lang.reflect.Field;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.leavesmc.leaves.bytebuf.packet.PacketType.*;
+
+public class InternalBytebufHandler {
+
+    class PacketHandler extends ChannelDuplexHandler {
+
+        private final static String handlerName = "leaves-bytebuf-handler";
+        private final Player player;
+
+        public PacketHandler(Player player) {
+            this.player = player;
+        }
+
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            if (msg instanceof BundlePacket<?> || msg instanceof BundleDelimiterPacket<?>) {
+                super.channelRead(ctx, msg);
+                return;
+            }
+            try {
+                msg = callPacketInEvent(player, createBytebufPacket((net.minecraft.network.protocol.Packet<?>) msg));
+            } catch (Exception e) {
+                MinecraftServer.LOGGER.error("Error on PacketInEvent.", e);
+            }
+            if (msg != null) {
+                super.channelRead(ctx, msg);
+            }
+
+        }
+
+        @Override
+        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+            if (msg instanceof BundlePacket<?> || msg instanceof BundleDelimiterPacket<?>) {
+                super.write(ctx, msg, promise);
+                return;
+            }
+            try {
+                msg = callPacketOutEvent(player, createBytebufPacket((net.minecraft.network.protocol.Packet<?>) msg));
+            } catch (Exception e) {
+                MinecraftServer.LOGGER.error("Error on PacketOutEvent.", e);
+            }
+            if (msg != null) {
+                super.write(ctx, msg, promise);
+            }
+        }
+    }
+
+    public final Map<PacketListener, Plugin> listenerMap = new HashMap<>();
+    private final BytebufManager manager = new SimpleBytebufManager(this);
+    private final ImmutableMap<PacketType, StreamCodec> type2CodecMap;
+
+    public InternalBytebufHandler() {
+        ImmutableMap.Builder<PacketType, StreamCodec> builder = ImmutableMap.builder();
+        for (PacketType packet : PacketType.values()) {
+            Class<?> packetClass = null;
+            try {
+                packetClass = Class.forName("net.minecraft.network.protocol.game." + packet.name() + "Packet");
+            } catch (ClassNotFoundException e) {
+                try {
+                    packetClass = Class.forName("net.minecraft.network.protocol.common." + packet.name() + "Packet");
+                } catch (ClassNotFoundException e2) {
+                    continue;
+                }
+            }
+            try {
+                Field field = packetClass.getDeclaredField("STREAM_CODEC");
+                builder.put(packet, (StreamCodec<FriendlyByteBuf, net.minecraft.network.protocol.Packet<?>>) field.get(null));
+            } catch (Exception ignored) {
+            }
+        }
+        builder.put(ClientboundMoveEntityPos, ClientboundMoveEntityPacket.Pos.STREAM_CODEC);
+        builder.put(ClientboundMoveEntityPosRot, ClientboundMoveEntityPacket.PosRot.STREAM_CODEC);
+        builder.put(ClientboundMoveEntityRot, ClientboundMoveEntityPacket.Rot.STREAM_CODEC);
+        builder.put(ServerboundMovePlayerPos, ServerboundMovePlayerPacket.Pos.STREAM_CODEC);
+        builder.put(ServerboundMovePlayerPosRot, ServerboundMovePlayerPacket.PosRot.STREAM_CODEC);
+        builder.put(ServerboundMovePlayerRot, ServerboundMovePlayerPacket.Rot.STREAM_CODEC);
+        builder.put(ServerboundMovePlayerStatusOnly, ServerboundMovePlayerPacket.StatusOnly.STREAM_CODEC);
+        type2CodecMap = builder.build();
+    }
+
+    public void injectPlayer(ServerPlayer player) {
+        player.connection.connection.channel.pipeline().addBefore("packet_handler", PacketHandler.handlerName, new PacketHandler(player.getBukkitEntity()));
+    }
+
+    public BytebufManager getManager() {
+        return manager;
+    }
+
+    public net.minecraft.network.protocol.Packet<?> callPacketInEvent(Player player, Packet packet) {
+        for (PacketListener listener : listenerMap.keySet()) {
+            if (listenerMap.get(listener).isEnabled()) {
+                packet = listener.onPacketIn(player, packet);
+                packet.bytebuf().resetReaderIndex();
+            } else {
+                listenerMap.remove(listener);
+            }
+        }
+        return createNMSPacket(packet);
+    }
+
+    public net.minecraft.network.protocol.Packet<?> callPacketOutEvent(Player player, Packet packet) {
+        for (PacketListener listener : listenerMap.keySet()) {
+            if (listenerMap.get(listener).isEnabled()) {
+                packet = listener.onPacketOut(player, packet);
+                packet.bytebuf().resetReaderIndex();
+            } else {
+                listenerMap.remove(listener);
+            }
+        }
+        return createNMSPacket(packet);
+    }
+
+    public void applyPacketToPlayer(Player player, Packet packet) {
+        Connection sp = ((CraftPlayer) player).getHandle().connection.connection;
+        sp.send(createNMSPacket(packet));
+    }
+
+    public net.minecraft.network.protocol.Packet<?> createNMSPacket(Packet packet) {
+        RegistryFriendlyByteBuf buf = new RegistryFriendlyByteBuf(((WrappedBytebuf) packet.bytebuf()).getFriendlyBytebuf(), MinecraftServer.getServer().registryAccess());
+        StreamCodec<FriendlyByteBuf, net.minecraft.network.protocol.Packet<?>> codec = type2CodecMap.get(packet.type());
+        if (codec == null) {
+            throw new UnsupportedOperationException("This feature is not completely finished yet, packet type " + packet.type() + " is not supported temporary.");
+        }
+        return codec.decode(buf);
+    }
+
+    private PacketType toEnumType(net.minecraft.network.protocol.PacketType<?> type) {
+        StringBuilder builder = new StringBuilder();
+        String bound = type.toString().split("/")[0];
+        String name = type.toString().split(":")[1];
+        builder.append(bound.substring(0, 1).toUpperCase()).append(bound.substring(1));
+        boolean flag = true;
+        for (int i = 0; i < name.length(); i++) {
+            if (flag) {
+                builder.append(name.substring(i, i + 1).toUpperCase());
+                flag = false;
+                continue;
+            }
+            if (name.charAt(i) == '_') {
+                flag = true;
+            } else {
+                builder.append(name.charAt(i));
+            }
+        }
+        try {
+            return PacketType.valueOf(builder.toString());
+        } catch (IllegalArgumentException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public Packet createBytebufPacket(net.minecraft.network.protocol.Packet<?> nmsPacket) {
+        PacketType type = toEnumType(nmsPacket.type());
+        RegistryFriendlyByteBuf buf = new RegistryFriendlyByteBuf(Unpooled.buffer(8192), MinecraftServer.getServer().registryAccess());
+        StreamCodec<FriendlyByteBuf, net.minecraft.network.protocol.Packet<?>> codec = type2CodecMap.get(type);
+        if (codec == null) {
+            throw new UnsupportedOperationException("This feature is not completely finished yet, packet type " + type + " is not supported temporary.");
+        }
+        codec.encode(buf, nmsPacket);
+        return new Packet(type, Bytebuf.of(buf.array()));
+    }
+}
